#我们在简单地用<或>时，相当于使用 0< 或 1>（下面会详细介绍）
#管道“|”(pipe line)，把上一个命令的 stdout 接到下一个命令的 stdin
#tee 命令的作用是在不影响原本 I/O 的情况下，将 stdout 复制一份到档案去

如果要深刻理解重定向，先要明白以下2点
1.shell(bash或者csh等)负责重定向，对于程序或者函数，这一切都是透明的，它只管输入输出，至于从哪输入哪输出，
  是shell解释器负责
2.shell命令解析过程中，在实际执行命令前，IO重定向先设置好

Example:
1.echo 1 a1 >a2 与 ‘echo 1 >a2 a1
	igi@igi-debian:~$ echo 1 a1 >a2
	igi@igi-debian:~$ cat a2
	1 a1
	igi@igi-debian:~$ rm a2
	igi@igi-debian:~$ echo 1 >a2 a1
	igi@igi-debian:~$ cat a2
	1 a1

#对标准文件（即0，1，2）的重定向
#标准输入：0
#标准输出：1
#标准错误：2

1.重定向输入输出，目标是文件word
	[n]<word    默认n为0
	[n]>word    默认n为1
	[n]>|word   默认n为1    noclobber选项有关，直接例子就明白它的用处了
	[n]>>word   默认n为1

2.重定向标准错误和标准输出到指定[文件描述符]
	&>word      更通用
	>&word
	>word 2>&1

	&>>word     没有>>&word的表达方法
	>>word 2>&1

#############################################################################
#简单重定向
	cmd > file
	把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，
	使用bash的noclobber选项可以防止覆盖原有文件。

	cmd >> file
	把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件后面。

	cmd < file
	使cmd命令从file读入

	cmd << text
	从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，
	此模式将对输入内容进行shell变量替换。如果使用 <<-
	则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考后面的例子

	cmd <<< word
	把word（而不是文件word）和后面的换行作为输入提供给cmd

	cmd <> file
	以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的

	cmd >| file
	功能同>，但即便在设置了noclobber时也会覆盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用>!实现这一功能。

#############################################################################
#文件描述符重定向(重新定义文件描述符都使用&,和&之间如果有空格则代表是文件，
											如果没有可以是文件描述符或文件 [< >仅仅是表示方向])
#使用文件描述符的重定向都使用了&符号。
	cmd >&n	    把输出送到文件描述符n
	cmd m>&n	把输出 到文件符m的信息重定向到文件描述符n
	cmd >&-	    关闭标准输出
	cmd <&n  	输入来自文件描述符n
	cmd m<&n	m来自文件描述各个n
	cmd <&-	    关闭标准输入
	cmd <&n-	移动输入文件描述符n而非复制它。（需要解释）
	cmd >&n-	移动输出文件描述符 n而非复制它。（需要解释）

#############################################################################
#重定向的组合应用
	cmd 2>file	     把文件描述符2重定向到file，即把错误输出存到file中。
	cmd > file 2>&1	 把标准错误重定向到标准输出，再重定向到file，即stderr和stdout都被输出到file中
	cmd &> file	     功能与上一个相同，更为简便的写法。
	cmd >& file	     功能仍与上一个相同。
	cmd > f1 2>f2	 把stdout重定向到f1，而把stderr重定向到f2
	tee files	     把stdout原样输出的同时，复制一份到files中。
	tee files	     把stderr和stdout都输出到files中，同时输出到屏幕。

#############################################################################
#shell的内建命令exec将并不启动新的shell，而是用要被执行命令替换当前的shell进程，
#并且将老进程的环境清理掉，而且exec命令后的其它命令将不再执行。 

#因此，如果你在一个shell里面，执行exec 
#ls那么，当列出了当前目录后，这个shell就自己退出了，因为这个shell进程已被替换为仅仅执行ls命令的一个进程，
#执行结束自然也就退出了。为了避免这个影响我们的使用，一般将exec命令放到一个shell脚本里面，
#用主脚本调用这个脚本，调用点处可以用bash a.sh，（a.sh就是存放该命令的脚本），这样会为a.sh建立一个sub
#shell去执行，当执行到exec后，该子脚本进程就被替换成了相应的exec的命令。 

#source命令或者"."，不会为脚本新建shell，而只是将脚本包含的命令在当前shell执行。 
#不过，要注意一个例外，当exec命令来对文件描述符操作的时候，就不会替换shell，而且操作完成后，还会继续执行接下来的命令。 

#exec 3<&0:这个命令就是将操作符3也指向标准输入。 

[root@vm57-120 ~]# exec 6<>/tmp/fd6 
# echo "df -h" >&6
# echo "ls -li" >&6 
# echo "free -m" >&6 
# cat /tmp/fd6      
df -h
ls -li
free -m 
  
# echo "du -sh /etc" >> &6
-bash: syntax error near unexpected token `&' 

先说另一个东西。文件操作。
$cat <from >to 2>&1

对标准文件（即0，1，2）的重定向，这我们都会。也就是说，在bash之下，我们只可以同时打开3个文件。
如果想对更多的文件同时打开并进行操作呢？
$exec 3> foobar
$ls >&3
$exec 3>&-

$exec 3< foobar
$cat <&3
$exec 3<&-

